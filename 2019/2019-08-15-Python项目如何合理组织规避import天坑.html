<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录分享Cygwin、Linux、编程等计算机技术"><title>Python项目如何合理组织规避import天坑 | silaoA的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Python项目如何合理组织规避import天坑</h1><a id="logo" href="/.">silaoA的博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Python项目如何合理组织规避import天坑</h1><div class="post-meta">Aug 15, 2019<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-module与package"><span class="toc-text">0x00 module与package</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#代码复用性和分层思想"><span class="toc-text">代码复用性和分层思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#module"><span class="toc-text">module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#package"><span class="toc-text">package</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-import"><span class="toc-text">0x01 import</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本形式"><span class="toc-text">基本形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#relative-import和absolute-import"><span class="toc-text">relative import和absolute import</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-项目组织建议"><span class="toc-text">0x02 项目组织建议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更多阅读"><span class="toc-text">更多阅读</span></a></li></ol></div></div><div class="post-content"><p>本文共3500余字，预计阅读时间12分钟，本文同步发布于知乎（账号silaoA）和微信公众号平台（账号伪码人）。<br>关注学习了解更多的Cygwin、Linux、Python等技术。</p>
<p>Python程序代码中经常需要import语句，从而调用已有的函数、方法等，但在多目录、多文件的项目程序中，容易遇到各种import错误，本文将通过合理化组织规避import带来的错误。<strong>本文描述针对Python3，Python2已过时并将进入无人维护状态，如是初学者建议直接选Python3。</strong></p>
<a id="more"></a>
<!-- [toc] -->
<h1 id="0x00-module与package"><a href="#0x00-module与package" class="headerlink" title="0x00 module与package"></a>0x00 module与package</h1><h2 id="代码复用性和分层思想"><a href="#代码复用性和分层思想" class="headerlink" title="代码复用性和分层思想"></a>代码复用性和分层思想</h2><p>程序代码如果完成的功能比较简单，放在一个文件里比较正常。如果随着需求变多，要完成的功能越来越多样化，那么正常的做法都是按照功能模块做好设计，将程序代码分割成多个目录、文件组织，每个文件完成各自的那部分功能即可。这样做的好处，一方面是便于维护，一旦发现bug方便快速定位和调试；另一方面是可以提高代码复用性，比如最基础、最常用的那部分代码文件，还可以被其他项目所用，不必从零开始重写。</p>
<p>还没见过哪种编程语言不支持多文件程序设计（如果真有，那也该淘汰了），Python也不例外。</p>
<p>既然支持多文件组织程序了，那么<code>如何组织</code>就是个大学问。在<a href="Cygwin系列（九）：Cygwin学习路线.html">Cygwin系列（九）：Cygwin学习路线</a>文中也提到了计算机系统粗略层次划分，在应用程序层面也可以照此继续细分更多层。<br><img src="../pic/计算机系统粗略层次划分.png" alt="计算机系统粗略层次划分"></p>
<p>照这个思路，可以简单地把程序再分为<code>驱动</code>和<code>应用</code>层，<code>驱动</code>负责实现基本操作、屏蔽细节，也可以叫<code>底层</code>；<code>应用</code>层根据<code>驱动</code>提供的接口调用相关函数，实现更高级的功能，也可以叫<code>上层</code>。比如Python中<code>len</code>、<code>sum</code>等函数，我们不用关心它是怎么实现的，也不需要重写求长度、求和的函数，自己写的程序代码只要按照接口规定传入参数即可得到预期结果，从而实现更高级的功能需求，那么提供<code>len</code>、<code>sum</code>等函数的代码文件就称为<code>底层</code>，我们自己写的代码可称为<code>上层</code>。更进一步地，我们自己写的代码可以划分更多层次出来，不难理解,<code>底层</code>与<code>上层</code>是相对而言的。</p>
<p>把编程比作建大楼，层次可以划分为 水泥沙子制作、砖头制作、墙体制作、楼房制作 4层，楼房制作层直接取用墙体搭建房子，必要时可以取用砖头，墙体制作层直接取用砖头形成各式各样的墙体，砖头制作层直接取用水泥沙子形成不同规格的砖头，而水泥沙子一般是有做好的。并且到了某次需要建大桥的时候，水泥沙子制作、砖头制作这些功能可以再用，不必重新实现，减少了工作量。</p>
<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>在Python中，一个.py文件就是一个module，即“模块”，<strong>模块的名称是文件名去掉末尾的’.py’</strong>。一个模块（A）中的变量、函数、类等符号，被其他模块（B）import之后，可被其他模块（B）引用。我们写程序代码的时候，就可以把代码分门别类地放在不同的.py文件中，按照各自的层级位置，实现各自的功能。</p>
<p>比如将程序分成<code>brick.py</code>、<code>wall.py</code>、<code>house.py</code>。</p>
<ul>
<li><code>brick.py</code>实现砖头制作函数，不同的参数指定砖头规格；</li>
<li><code>wall.py</code>中<code>import brick</code>，调用函数得到不同规格砖头，组装形成墙体；</li>
<li><code>house.py</code>是主程序，<code>import wall</code>后调用函数得到墙体，必要时也可以<code>import brick</code>制作特定的砖头，最后统一组装成房子。</li>
</ul>
<p>Python是“电池内置”型（battery included）语言，初次安装Python解释器时会一并安装很多基础的模块和包，称为“标准库（standard library）”，在Python安装路径的<code>lib</code>子目录下可看到。此外，用户可以自行安装其他第三方库，默认会放在<code>lib/site-packages</code>子目录下。</p>
<p>有的模块出于运行效率考虑，是被编译进Python解释器的，并不以<code>.py</code>文件形式存在，比如常用的<code>builtins</code>、<code>sys</code>等。内置的<code>len()</code>函数、加减乘除运算等就在<code>builtins</code>模块中，使用时甚至不需要我们import，Python解释器在启动时便已import好了，而<code>sys</code>模块需要先import才能使用。</p>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>自己写的模块应该避免与Python内置模块重名，但不同人编写的模块名称相同怎么办？为解决名称冲突问题，Python引入按照目录组织模块的方法，创造了package（包）的概念。包是一个特殊的目录，其下<strong>必须</strong>含有名为<code>__init__.py</code>的文件，否则Python会将其当作普通目录而不是包，目录下<code>__init__.py</code>文件对应的模块名就是包（目录）名，<strong>文件内容可以为空</strong>。</p>
<p>有了包，只要顶层包名称与其他人不发生冲突，模块名称便不会冲突。如下目录组织，顶层包为<code>soud</code>目录，import成功后，相应模块名称为<code>sound.example</code>、<code>sound.formats.wavread</code>、<code>sound.effects.echo</code>、<code>sound.filters.vocoder</code>等，要引用模块中的变量、函数符号，按照<code>模块名.符号名</code>方式使用即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sound/                          <span class="comment"># 顶层包</span></span><br><span class="line">      __init__.py               <span class="comment"># 初始化sound包</span></span><br><span class="line">      formats/                  <span class="comment"># 子包formats</span></span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects/                  <span class="comment"># 子包effects</span></span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters/                  <span class="comment"># 子包filters</span></span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br><span class="line">      example.py</span><br></pre></td></tr></table></figure></p>
<h1 id="0x01-import"><a href="#0x01-import" class="headerlink" title="0x01 import"></a>0x01 import</h1><h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h2><p>import语句支持两种形式：</p>
<ul>
<li>import xx</li>
</ul>
<ul>
<li><code>xx</code>是模块名（指含包路径的模块全名）的话，通过<code>xx.符号</code>的形式访问函数、变量、类。</li>
<li><code>xx</code>仅是包名的话，只会import到包下子模块，并不会自动import子包，可以通过<code>xx.mod1.符号</code>的形式访问函数、变量、类，通常会在包下的<code>__init__.py</code>中写入import子包语句，这样便能通过<code>xx.subpack1.mod2.符号</code>形式访问mod2中的函数、变量、类，还有更多技巧进一步简化访问子包下模块内的符号。</li>
<li><code>xx</code>不能定位到任何函数、变量、类名。</li>
</ul>
<ul>
<li>from xx import yy</li>
</ul>
<ul>
<li><code>xx</code>是模块名（指含包路径的模块全名）的话，<code>yy</code>就定位到具体的函数、变量、类。</li>
<li><p><code>xx</code>是包名的话，<code>yy</code>可以定位到子包、模块或具体的函数、变量、类，比如<code>from sound import __version__</code>，Python解释器首先检测<code>__version__</code>是否为<code>sound/__init__.py</code>中定义的符号，若不是，再检测是否存在<code>sound.__version__</code>模块，如不存在便报错。如果<code>yy</code>是<code>*</code>，那么代表引入<code>xx</code>模块中定义的所有符号；对于包，可以在包下<code>__init__.py</code>文件定义<code>__all__</code>变量规定允许导出的所有符号或模块，如无<code>__all__</code>定义，则该语句只负责import<code>xx</code>包，执行包下<code>__init__.py</code>文件，当然文件内可以import子模块或子包。<code>from xx import *</code>形式容易造成命名冲突，建议慎用！</p>
<p>以上两种形式，可以后续加<code>as</code>表达式，对import的对象取别名，如<code>import numpy as np</code>。</p>
</li>
</ul>
<p><code>equalizer.py</code>、<code>vocoder.py</code>文件在同级目录下，<code>equalizer.py</code>中使用<code>import vocoder</code>或者<code>from vocoder import xx</code>,然后运行<code>python sound/filters/equalizer.py</code>是不会报<code>ImportError</code>错误的。那么，不在同级目录下该怎么处理呢？</p>
<h2 id="relative-import和absolute-import"><a href="#relative-import和absolute-import" class="headerlink" title="relative import和absolute import"></a>relative import和absolute import</h2><p>简单来说，相对导入（relative import）的语句通过使用<code>.</code>或<code>..</code>等相对路径的方式来定位要import的模块/包，基准路径是当前模块所在包，如在<code>sound/effects/reverse.py</code>中，基准路径是<code>sound.effects</code>包，使用下属语句都是合法的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> echo                <span class="comment"># 对应模块 ./echo.py</span></span><br><span class="line"><span class="keyword">from</span> .surround <span class="keyword">import</span> XXX         <span class="comment"># 对应模块 ./surround.py内的XXX符号</span></span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> formats            <span class="comment"># 对应包 ../formats</span></span><br><span class="line"><span class="keyword">from</span> ..filters <span class="keyword">import</span> equalizer   <span class="comment"># 对应模块  ..filters/equalizer.py</span></span><br><span class="line"><span class="keyword">from</span> ... <span class="keyword">import</span> example           <span class="comment"># 对应模块 ../../example.py</span></span><br></pre></td></tr></table></figure></p>
<p>但在执行<code>python sound/effects/reverse.py</code>时便会报<code>ModuleNotFoundError</code>错误，这是因为执行语句将<code>sound/effects/reverse.py</code>当做主模块（main module），主模块的名称在运行时会被Python强制命名为<code>__main__</code>，从而找不到<code>__main__.echo</code>模块，规避的正确方式是使用<code>-m</code>选项运行指定模块，即<code>python -m sound.effects.reverse</code>运行正常。相对导入方式可以解决导入当前目录、上级目录、上上级目录下模块的需求，但<strong>使用相对导入的文件不能直接以脚本方式运行，只能以模块方式（-m选项）运行，并且当前路径要处于import语句定位的路径或更高层路径</strong>。</p>
<p>绝对导入（absolute import）与上相反，不使用<code>.</code>或<code>..</code>定位要import的模块/包的路径，而使用完整路径定位模块/包，Python根据<code>sys.path</code>的值逐路径搜索要导入的模块/包，而对于内置的和安装第三方的模块/包，其路径都在<code>sys.path</code>值中。<strong>绝对导入的方式无法导入上级目录的模块</strong>，虽然可以通过在程序中改写<code>sys.path</code>追加特定路径的方式规避，但不推荐，会增加风险；<strong>使用绝对导入的文档，应使用脚本方式直接运行</strong>。</p>
<h1 id="0x02-项目组织建议"><a href="#0x02-项目组织建议" class="headerlink" title="0x02 项目组织建议"></a>0x02 项目组织建议</h1><p>为提高代码复用和有效模块化组织，建议使用主程序+包的方式组织项目，其中包内按分层思想放置若干模块，包内模块间使用相对导入（relative import），项目根目录下放置主程序文件。仍以开头建大楼为例，组织如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">projectname/              <span class="comment"># 项目目录</span></span><br><span class="line">    <span class="comment">#__init__.py          # 也可以变成包，供今后其他项目import</span></span><br><span class="line">    construct/            <span class="comment"># 子包construct用于建造过程</span></span><br><span class="line">        __init__.py</span><br><span class="line">        brick.py          <span class="comment"># 制作砖头</span></span><br><span class="line">        wall.py           <span class="comment"># 制作墙体</span></span><br><span class="line">        misc.py           <span class="comment"># 其他不好归类的功能</span></span><br><span class="line">        ...</span><br><span class="line">    decoration/           <span class="comment"># 子包decoration用于装修装饰过程</span></span><br><span class="line">        __init__.py</span><br><span class="line">        room.py           <span class="comment"># 放间装修装饰</span></span><br><span class="line">        clean.py          <span class="comment"># 清洁</span></span><br><span class="line">        ...</span><br><span class="line">    doc/                  <span class="comment"># 项目文档目录</span></span><br><span class="line">    buildhouse.py         <span class="comment"># 项目主程序，如果较复杂应继续分拆</span></span><br><span class="line">    README.md             <span class="comment"># 项目简介</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>在<code>construct</code>包下，对<code>brick</code>模块都使用<code>from .brick import (XX, YY, ZZ)</code>的形式，明确要import的变量、函数、类名称；</li>
<li>同时，在<code>__init__.py</code>中使用<code>from .brick import (XX, YY, ZZ)</code>、<code>from .wall import (AA, BB, CC)</code>等把这些<strong>可以对外导出</strong>的符号import一遍，这样<code>construct</code>包被<code>construct</code>包下模块或主程序<code>buildhouse.py</code>导入时，可以简化为<code>from ..construct import (XX, CC)</code>、<code>from construct import (AA, BB, CC, XX, YY, ZZ)</code>或<code>import construct</code>。</li>
<li>尽可能地减少在import语句使用 “*“ 符号，实在无法避免时，为限制 “*“ 符号带来的命名冲突，在<code>construct/__init__.py</code>、<code>decoration/__init__.py</code>文件中，定义<code>__all__</code>变量，明确限定允许被导出的所有符号。</li>
<li>主程序运行时，先切换到<code>projectname</code>目录下，再执行<code>python buildhouse.py</code>，或者直接<code>python path/to/projectname/buildhouse.py</code></li>
</ul>
<p>若项目进一步复杂，一方面可能增加更多的包，另一方面在包目录之下可以增加子包，使层次更加清晰明了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://medium.com/pyladies-taiwan/python-%E7%9A%84-import-%E9%99%B7%E9%98%B1-3538e74f57e3" target="_blank" rel="noopener">Python的import陷阱</a></li>
<li>Python 3.6.7 Documentation - The Python Tutorial.</li>
</ul>
<h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><ul>
<li><a href="2019-02-05-Cygwin前传：从割据到互补.html">Cygwin前传：从割据到互补</a></li>
<li><a href="2019-02-14-Cygwin系列（一）：Cygwin是什么.html">Cygwin系列（一）：Cygwin是什么</a></li>
<li><a href="Cygwin系列（九）：Cygwin学习路线.html">Cygwin系列（九）：Cygwin学习路线</a></li>
<li><a href="2019-04-04-Linux Cygwin知识库（一）：一文搞清控制台、终端、shell概念.html">Linux Cygwin知识库（一）：一文搞清控制台、终端、shell概念</a> </li>
<li><a href="2019-05-04-Linux Cygwin知识库（二）：目录、文件及基本操作.html">Linux Cygwin知识库（二）：目录、文件及基本操作</a></li>
</ul>
<hr>
<p><strong>如本文对你有帮助，或内容引起极度舒适，欢迎分享转发或点击下方捐赠按钮打赏</strong> ^_^</p>
</div><iframe src="/donate/?AliPayQR=/pic/AliPayQR.jpg&amp;WeChatQR=/pic/WeChatQR.png&amp;GitHub=https://github.com/Kaiyuan/donate-page&amp;BTCQR=undefined&amp;BTCKEY=undefined&amp;PayPal=undefined" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>silaoA</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/2019-08-15-Python项目如何合理组织规避import天坑.html">https://silaoa.github.io/2019/2019-08-15-Python项目如何合理组织规避import天坑.html</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文为原创文章，如需转载，请联系stsilaoa@gmail.com 或 公众号 伪码人 或知乎私信 silaoA。</li></ul></div><br><div class="tags"><a href="/tags/Python/">Python</a></div><div class="post-nav"><a class="next" href="/2019/2019-06-16-Cygwin系列（九）：Cygwin学习路线.html">Cygwin系列（九）：Cygwin学习路线</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://silaoa.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">18</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/机器人/" style="font-size: 15px;">机器人</a> <a href="/tags/Cygwin/" style="font-size: 15px;">Cygwin</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/Web/" style="font-size: 15px;">Web</a> <a href="/tags/爬虫/" style="font-size: 15px;">爬虫</a> <a href="/tags/IEEE/" style="font-size: 15px;">IEEE</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/科技/" style="font-size: 15px;">科技</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/WSL/" style="font-size: 15px;">WSL</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/2019-08-15-Python项目如何合理组织规避import天坑.html">Python项目如何合理组织规避import天坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/2019-06-16-Cygwin系列（九）：Cygwin学习路线.html">Cygwin系列（九）：Cygwin学习路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/2019-05-25-Cygwin系列（八）：命令行软件包管理器apt-cyg.html">Cygwin系列（八）：命令行软件包管理器apt-cyg</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/2019-05-12-Cygwin系列（七）：Cygwin软件包管理相关配置.html">Cygwin系列（七）：Cygwin软件包管理相关配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/2019-05-08-微软WSL——Linux桌面未来之光.html">微软WSL——Linux桌面版未来之光</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/2019-05-05-IEEE-Spectrum-20190415-为太空而生的充气机器人.html">IEEE-Spectrum-20190415-为太空而生的充气机器人</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/2019-05-04-Linux Cygwin知识库（二）：目录、文件及基本操作.html">Linux Cygwin知识库（二）：目录、文件及基本操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/2019-04-18-hexo-github-pages建博客站全过程记录.html">hexo+github pages搭建博客站全过程记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/2019-04-10-使用hexo写博客.html">使用hexo写博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/2019-04-04-Linux Cygwin知识库（一）：一文搞清控制台、终端、shell概念.html">Linux Cygwin知识库（一）：一文搞清控制台、终端、shell概念</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://silaoa.github.io" title="silaoA的网络日志" target="_blank">silaoA的网络日志</a><ul></ul><a href="http://www.zhihu.com/people/laoa-si/posts" title="silaoA的知乎文章" target="_blank">silaoA的知乎文章</a><ul></ul><a title="微信公众号：伪码人（We_Coder）" target="_blank">微信公众号：伪码人（We_Coder）</a><ul></ul><a title="QQ交流群：374791536" target="_blank">QQ交流群：374791536</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">silaoA的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div></body></html>